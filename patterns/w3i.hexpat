#pragma description Warcraft.w3i
#pragma endian little
#pragma array_limit 999999

import std.io;
import std.mem;
import std.string;
import std.core;

u32 format @ 0x00; // ROC=18, TFT=25, 1.31=28, 1.32=31

bitfield MapFlags {
    hide_minimap: 1; // 0x000001    Скрыть мини-карту на экранах предпросмотра
    b2: 1; // 0x000002    Изменить приоритеты союзников
    melee: 1; // 0x000004    Карта подходит для режима "Сражения"
    b4: 1; // 0x000008    Использовать нестандартный тип ландшафта
    b5: 1; // 0x000010    Скрытые области частично видимы
    b6: 1; // 0x000020    Фикс. параметры игрока
    b7: 1; // 0x000040    Нестандартные кланы
    b8: 1; // 0x000080    Нестандартные технологии
    b9: 1; // 0x000100    Нестандартные способности
    b10: 1; // 0x000200    Нестандартные улучшения
    b11: 1; // 0x000400    Неизвестно
    b12: 1; // 0x000800    Показывать волны на крутых берегах
    b13: 1; // 0x001000    Показывать волны на пологих берегах
    b14: 1; // 0x002000    Используется туман на местности
    b15: 1; // 0x004000    Требуется дополнение
    b16: 1; // 0x008000    Классификация предметов
    b17: 1; // 0x010000    Фоновый цвет воды
    padding: 15;
};


struct Player {
    u32 num; // Номер игрока
    u32 type; // 1=Человек, 2=Компьютер, 3=Нейтрал, 4=Резерв
    u32 race; // 0=Случайная раса, 1=Альянс, 2=Орда, 3=Нежить, 4=Ночные эльфы
    u32 fix; // Фиксированная исходная позиция  Самый младший бит (0=нет, 1=да)
    char name[]; // Имя игрока
    float pos[2]; // координата стартовой позиции
    u32 p_down; //iНизкие приоритеты союзников    От младшего бита к старшему (0=приоритета на игрока нету, 1=приоритет на игрока есть)
    u32 p_up; //int Высокие приоритеты союзников  От младшего бита к старшему (0=приоритета на игрока нету, 1=приоритет на игрока есть)
    if (format >= 31){
        u32;
        u32;
    }
};

bitfield ClanFlags {
    f1: 1; // 0x0001  Союзник
    f2: 1; // 0x0002  Общая победа
    f3: 1; // 0x0004  Неизвестно
    f4: 1; // 0x0008  Общее поле зрения
    f5: 1; // 0x0010  Общие войска
    f6: 1; // 0x0020  Общие войска:все
    padding: 26;
};

struct Clan {
    ClanFlags flags;
    u32 players; // От младшего бита к старшему (0=игрока нету в клане, 1=игрок есть в клане), но надо учитывать наличие самого игрока в игре, т.к в первом клане по умолчанию присутствуют все игроки (от 0 до 31), которых нету в других кланах
    char name[]; // Название клана
};

struct Upgrade {
    u32 players; //int Игроки    От младшего бита к старшему (0=на игрока не действует улучшение, 1=на игрока действует улучшение)
    char id[4]; // Равкод улучшения
    u32 level; //int Уровень улучшения
    u32 status; //int Доступность улучшения   0=Недоступно, 1=Доступно, 2=Исследовано
};

struct Tech {
    u32 players; //int Игроки    От младшего бита к старшему (0=игроку ДОСТУПНА технология, 1=игроку НЕ ДОСТУПНА технология)
    char id[4]; // Равкод технологии   Это может быть: предмет, юнит, способность
};


struct Chance {
    u32 chance; //int Шанс (в процентах)
    char ids[Group.j*4]; //   Равкоды
};

struct Group {
    u32 num; //int Номер группы
    char name []; //string  Название группы

    u32 j; //int Кол-во позиций (колонн)   Переменная j
    u32 j_type[j]; // Тип позиций   0=Войска, 1=Здания, 2=Предметы

    u32 k; // int Кол-во наборов (рядов) Переменная k
    Chance chances[k];
};


struct ItemChance {
    u32 chance; //int Шанс (в процентах)
    char ids[4]; // Равкод предмета
};

struct ItemGroup {
    u32 k; //int Кол-во предметов в наборе  Переменная k
    ItemChance chances[k];
};

struct Item {
    u32 num; // int Номер таблицы
    char name[]; // string  Название таблицы
    u32 j; // int Кол-во наборов предметов   Переменная j
    ItemGroup groups[j];
};


struct Data {
    u32 save_count;
    u32 editor_version;
    if (format > 28){
        u32 editor_version_full[4];
    }
    char map_name[];
    char author[];
    char description[];
    char players_description[];
    float cam_bounds[8]; // Лево, вниз, вправо, вверх, лево, вверх, вправо, вниз
    s32 map_size[4]; // Размеры неигровой области карты Переменные A, B, C, D см. ниже
    u32 map_width; //Ширина игровой области карты   E, ширина карты = A+E+B
    u32 map_height; // Высота игровой области карты   F, высота карты = C+F+D
    MapFlags map_flags;
    char land; // Основной тип ландшафта карты
    s32 loadscreen_num; // Номер загрузочного экрана от стандартных кампаний -1 = нету или используется импортированный загрузочный экран
    if (format >= 25) char loadscreen_path[]; // Путь импортированного загрузочного экрана
    char loadscreen_text[]; // Текст загрузочного экрана
    char loadscreen_title[]; // Заголовок загрузочного экрана
    char loadscreen_subtitle[]; // Подзаголовок загрузочного экрана
    u32 game_data_set; // Используемый набор игровых данных Номер предустановки, 0=Стандартный
    if (format >= 25) char prologue_path[]; // Путь импортированного экрана пролога
    char prologue_text[]; // Текст экрана пролога
    char prologue_title[]; // Заголовок экрана пролога
    char prologue_subtitle[]; // Подзаголовок экрана пролога
    if (format >= 25) {
        u32 fog; // 0=Не используется, больше нуля = номер в списке стилей тумана
        float fog_start; // Начальная Z-высота тумана
        float fog_end; // Конечная Z-высота тумана
        float fog_density; // Плотность тумана
        u32 fog_color; // Цвет тумана RGBA
        char weather[4]; // Равкод глобальной погоды на карте
        char sound[]; // Нест. звуковое окружение
        char light; // Нестандартное освещение Пример: 'A' - Ашенваль, 'L' - Летний Лордерон
        u32 water_color; // Фоновый цвет воды RGBA
    }
    if (format >= 28) u32 is_lua; // 0=JASS, 1=Lua
    if (format >= 31){
        u32;
        u32;
    }

    u32 player_count; // Кол-во игроков
    Player players[player_count];

    u32 clan_count; // Кол-во кланов
    Clan clans[clan_count];

    u32 upgrade_count; // Кол-во нестандартных улучшений
    Upgrade upgrades[upgrade_count];

    u32 tech_count; // Кол-во нестандартных технологий
    Tech techs[tech_count];

    u32 group_count; // Кол-во случайных групп
    Group groups[group_count];

    if (format >= 25){
        u32 item_count; // Кол-во таблиц предметов
        Item items[item_count];
    }
};


Data data @0x04;
